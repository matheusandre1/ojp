package org.openjproxy.grpc.server.action.statement;

import com.openjproxy.grpc.DbName;
import com.openjproxy.grpc.OpResult;
import com.openjproxy.grpc.ResultType;
import com.openjproxy.grpc.SessionInfo;
import com.openjproxy.grpc.StatementRequest;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.lang3.StringUtils;
import org.openjproxy.constants.CommonConstants;
import org.openjproxy.grpc.ProtoConverter;
import org.openjproxy.grpc.dto.Parameter;
import org.openjproxy.grpc.server.ConnectionSessionDTO;
import org.openjproxy.grpc.server.LobDataBlocksInputStream;
import org.openjproxy.grpc.server.action.ValueAction;
import org.openjproxy.grpc.server.action.session.SessionConnectionAction;
import org.openjproxy.grpc.server.action.session.SessionConnectionRequest;
import org.openjproxy.grpc.server.sql.SqlSessionAffinityDetector;
import org.openjproxy.grpc.server.statement.ParameterHandler;
import org.openjproxy.grpc.server.statement.StatementFactory;
import org.openjproxy.grpc.server.utils.StatementRequestValidator;

import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import org.openjproxy.grpc.server.action.ActionContext;
import lombok.Value;
import lombok.Builder;

/**
 * Internal action for executing updates without segregation logic.
 * Extracted from StatementServiceImpl.executeUpdateInternal().
 */
@Slf4j
public class ExecuteUpdateInternalAction
        implements ValueAction<ExecuteUpdateInternalAction.ExecuteUpdateInternalRequest, OpResult> {

    @Value
    @Builder
    public static class ExecuteUpdateInternalRequest {
        ActionContext context;
        StatementRequest statementRequest;
    }

    private static final ExecuteUpdateInternalAction INSTANCE = new ExecuteUpdateInternalAction();

    private ExecuteUpdateInternalAction() {
        // Private constructor prevents external instantiation
    }

    public static ExecuteUpdateInternalAction getInstance() {
        return INSTANCE;
    }

    @Override
    public OpResult execute(ExecuteUpdateInternalRequest internalRequest) throws SQLException {
        StatementRequest request = internalRequest.getStatementRequest();
        ActionContext context = internalRequest.getContext();

        int updated = 0;
        SessionInfo returnSessionInfo = request.getSession();
        ConnectionSessionDTO dto = ConnectionSessionDTO.builder().build();

        Statement stmt = null;
        String psUUID = "";
        OpResult.Builder opResultBuilder = OpResult.newBuilder();

        try {
            // Check if SQL requires session affinity (temporary tables, session variables,
            // etc.)
            boolean requiresSessionAffinity = SqlSessionAffinityDetector.requiresSessionAffinity(request.getSql());

            // Use SessionConnectionAction
            SessionConnectionRequest sessionConnRequest = SessionConnectionRequest.builder()
                    .context(context)
                    .sessionInfo(request.getSession())
                    .startSessionIfNone(StatementRequestValidator.isAddBatchOperation(request)
                            || StatementRequestValidator.hasAutoGeneratedKeysFlag(request)
                            || requiresSessionAffinity)
                    .build();

            dto = SessionConnectionAction.getInstance().execute(sessionConnRequest);
            returnSessionInfo = dto.getSession();

            List<Parameter> params = ProtoConverter.fromProtoList(request.getParametersList());
            PreparedStatement ps = dto.getSession() != null && StringUtils.isNotBlank(dto.getSession().getSessionUUID())
                    && StringUtils.isNoneBlank(request.getStatementUUID())
                            ? context.getSessionManager().getPreparedStatement(dto.getSession(),
                                    request.getStatementUUID())
                            : null;

            if (CollectionUtils.isNotEmpty(params) || ps != null) {
                if (StringUtils.isNotEmpty(request.getStatementUUID())) {
                    Collection<Object> lobs = context.getSessionManager().getLobs(dto.getSession());
                    for (Object o : lobs) {
                        LobDataBlocksInputStream lobIS = (LobDataBlocksInputStream) o;
                        Map<String, Object> metadata = (Map<String, Object>) context.getSessionManager().getAttr(
                                dto.getSession(),
                                lobIS.getUuid());
                        Integer parameterIndex = (Integer) metadata
                                .get(CommonConstants.PREPARED_STATEMENT_BINARY_STREAM_INDEX);
                        ps.setBinaryStream(parameterIndex, lobIS);
                    }
                    if (DbName.POSTGRES.equals(dto.getDbName())) {// Postgres requires check if the lob streams are
                                                                  // fully consumed.
                        context.getSessionManager().waitLobStreamsConsumption(dto.getSession());
                    }
                    if (ps != null) {
                        ParameterHandler.addParametersPreparedStatement(context.getSessionManager(), dto.getSession(),
                                ps, params);
                    }
                } else {
                    ps = StatementFactory.createPreparedStatement(context.getSessionManager(), dto, request.getSql(),
                            params,
                            request);
                    if (StatementRequestValidator.hasAutoGeneratedKeysFlag(request)) {
                        String psNewUUID = context.getSessionManager().registerPreparedStatement(dto.getSession(), ps);
                        opResultBuilder.setUuid(psNewUUID);
                    }
                }
                if (StatementRequestValidator.isAddBatchOperation(request)) {
                    ps.addBatch();
                    if (request.getStatementUUID().isBlank()) {
                        psUUID = context.getSessionManager().registerPreparedStatement(dto.getSession(), ps);
                    } else {
                        psUUID = request.getStatementUUID();
                    }
                } else {
                    updated = ps.executeUpdate();
                }
                stmt = ps;
            } else {
                stmt = StatementFactory.createStatement(context.getSessionManager(), dto.getConnection(), request);
                updated = stmt.executeUpdate(request.getSql());
            }

            if (StatementRequestValidator.isAddBatchOperation(request)) {
                return opResultBuilder
                        .setType(ResultType.UUID_STRING)
                        .setSession(returnSessionInfo)
                        .setUuidValue(psUUID).build();
            } else {
                return opResultBuilder
                        .setType(ResultType.INTEGER)
                        .setSession(returnSessionInfo)
                        .setIntValue(updated).build();
            }
        } finally {
            // If there is no session, close statement and connection
            if (dto.getSession() == null || StringUtils.isEmpty(dto.getSession().getSessionUUID())) {
                if (stmt != null) {
                    try {
                        stmt.close();
                    } catch (SQLException e) {
                        log.error("Failure closing statement: " + e.getMessage(), e);
                    }
                    try {
                        if (stmt.getConnection() != null) {
                            stmt.getConnection().close();
                        }
                    } catch (SQLException e) {
                        log.error("Failure closing connection: " + e.getMessage(), e);
                    }
                }
            }
        }
    }
}
