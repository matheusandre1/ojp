# Session Affinity Analysis for Session-Specific SQL Operations

## Executive Summary

**Question**: Does OJP support session affinity for session-specific database features like temporary tables and session variables?

**Answer**: **NO** - OJP currently does NOT automatically detect and enforce session affinity for SQL operations like `CREATE TEMPORARY TABLE` or `SET SESSION` variables.

**Current State**: Session affinity (via `sessionUUID` binding) is only triggered by:
- JDBC-level operations (batch, auto-generated keys, LOBs)
- Explicit transaction boundaries
- Query result set handling

**Impact**: Operations like temporary tables and session variables may execute on different backend connections across a connection pool, breaking their session-specific semantics.

---

## Current Session Affinity Implementation

### What Works Today

OJP implements multinode session stickiness through the following mechanism:

1. **Session Creation**: A `sessionUUID` is generated when:
   - A query is executed (needs result set)
   - Batch operations are used
   - Auto-generated keys are requested
   - LOB objects are created
   - Explicit transactions are started
   - Resources (Statement, PreparedStatement, Connection) are called

2. **Session Binding**: Once created, the session maps to:
   - A specific backend `Connection` on the server
   - A specific OJP server node in multinode deployments
   - File: `MultinodeConnectionManager.java` maintains `sessionToServerMap`

3. **Routing**: Subsequent operations with the same `sessionUUID` are routed to:
   - The same backend connection (via `SessionManager.getConnection()`)
   - The same OJP server node (via `affinityServer()` method)

**Reference Documentation**:
- `documents/multinode/README.md` lines 99-103
- `documents/multinode/multinode-architecture.md` lines 355-365

### Architecture Flow

```
Client Request with sessionUUID
    ↓
MultinodeStatementService.executeWithSessionStickiness()
    ↓
MultinodeConnectionManager.affinityServer(sessionUUID)
    ↓
sessionToServerMap.get(sessionUUID) → Returns bound server
    ↓
Server: SessionManager.getSession(sessionInfo)
    ↓
Returns same dedicated Connection object
```

---

## The Problem: Session-Specific SQL Is Not Detected

### Root Cause

**OJP does not parse SQL content** to determine if session affinity is required.

Session creation is purely based on:
1. **JDBC operation flags** (from gRPC protocol)
2. **Statement resource types** (Statement, PreparedStatement, Connection)
3. **Explicit transaction boundaries**

### Evidence from Code Analysis

#### 1. No SQL Parsing Logic

**Finding**: Searched entire codebase for SQL pattern detection:
```bash
grep -r "CREATE TEMPORARY TABLE" ojp-server/
grep -r "SET SESSION" ojp-server/
grep -r "CREATE TEMP TABLE" ojp-server/
```
**Result**: No matches found. Server does not inspect SQL content.

**Files Examined**:
- `StatementServiceImpl.java`: Executes SQL directly without parsing
- `StatementRequestValidator.java`: Only validates JDBC flags, not SQL content
- `CallResourceAction.java`: Operates on JDBC resource types

#### 2. Session Creation Trigger Points

**File**: `ojp-server/src/main/java/org/openjproxy/grpc/server/StatementServiceImpl.java`

```java
// Line 491 - Sessions created for ALL queries (for result set handling)
ConnectionSessionDTO dto = this.sessionConnection(request.getSession(), true);

// Line 366-367 - Sessions for batch ops or auto-generated keys
if (StatementRequestValidator.isAddBatchOperation(request) || 
    StatementRequestValidator.hasAutoGeneratedKeysFlag(request)) {
    dto = this.sessionConnection(sessionInfo, true);
}

// Line 533 - No session creation for fetch operations
ConnectionSessionDTO dto = this.sessionConnection(request.getSession(), false);
```

**File**: `ojp-server/src/main/java/org/openjproxy/grpc/server/StatementRequestValidator.java`

```java
// Lines 22-43 - Only JDBC flag validation
public static boolean isAddBatchOperation(StatementRequest request) {
    return request.getMethodName().contains("addBatch");
}

public static boolean hasAutoGeneratedKeysFlag(StatementRequest request) {
    ParameterValue param = request.getParametersMap()
        .get(STATEMENT_AUTO_GENERATED_KEYS_KEY);
    return param != null && param.getIntValue() == Statement.RETURN_GENERATED_KEYS;
}
```

**No SQL content inspection** - only method names and JDBC flags.

#### 3. Protocol Design

**File**: `ojp-grpc-commons/src/main/proto/StatementService.proto`

```protobuf
// Lines 185-186
//only set if connection has to be the same among different requests, 
//within transaction boundaries or when using LOB objects.
string sessionUUID = 3;
```

**Comment explicitly mentions**: transactions and LOBs, but **NOT temporary tables or session variables**.

---

## Problematic Scenarios

### Scenario 1: Temporary Tables

**SQL Sequence**:
```sql
-- Request 1: Create temporary table (no explicit transaction)
CREATE TEMPORARY TABLE temp_data (id INT, name VARCHAR(100));

-- Request 2: Insert into temporary table
INSERT INTO temp_data VALUES (1, 'Alice');

-- Request 3: Query temporary table
SELECT * FROM temp_data;
```

**What Happens in OJP**:

| Request | Session Created? | Reason | Backend Connection |
|---------|-----------------|--------|-------------------|
| CREATE TEMP TABLE | YES (for query execution) | All queries create sessions | Connection A |
| INSERT | YES (for DML execution) | Auto-generated keys or batch detection | **Could be Connection B** ❌ |
| SELECT | YES (for result set) | All queries create sessions | **Could be Connection C** ❌ |

**Problem**: Each request might get a **different session** (thus different backend connection) because:
- No SQL parsing detects "CREATE TEMPORARY TABLE"
- Each operation creates a new session if no `sessionUUID` is provided
- Client doesn't know to reuse the same session across requests

**Expected Behavior**: All three operations should use the **same backend connection** (same session).

### Scenario 2: Session Variables

**SQL Sequence**:
```sql
-- Request 1: Set session variable
SET @user_id = 12345;

-- Request 2: Use session variable in query
SELECT * FROM orders WHERE user_id = @user_id;
```

**What Happens in OJP**:

| Request | Session Created? | Backend Connection |
|---------|-----------------|-------------------|
| SET @user_id | YES (DML execution) | Connection A |
| SELECT with @user_id | YES (query execution) | **Could be Connection B** ❌ |

**Problem**: The `SELECT` query on Connection B won't see the `@user_id` variable set on Connection A.

**Expected Behavior**: Both operations should use the **same backend connection** (same session).

### Scenario 3: Database-Specific Session State

**Examples**:
- **PostgreSQL**: `SET LOCAL`, `CREATE TEMP TABLE`, `PREPARE` statements
- **MySQL**: `SET SESSION`, `@@ variables`, `PREPARE` statements  
- **Oracle**: `DBMS_SESSION.SET_CONTEXT`, temporary tables with `ON COMMIT DELETE ROWS`
- **SQL Server**: `##temp_table` (global temp), `#temp_table` (session temp)

**Problem**: None of these are detected by SQL content inspection.

---

## Current Session Management Behavior

### How Sessions Are Created Today

**File**: `ojp-server/src/main/java/org/openjproxy/grpc/server/Session.java`

```java
// Lines 49-59
public Session(Connection connection, String connectionHash, String clientUUID) {
    this.connection = connection;
    this.connectionHash = connectionHash;
    this.clientUUID = clientUUID;
    this.sessionUUID = UUID.randomUUID().toString(); // Always generates new UUID
    this.closed = false;
    // ... initialization
}
```

**Key Point**: Every call to `createSession()` generates a **new, unique sessionUUID**.

### When Sessions Are Reused

Sessions are reused (same `sessionUUID` across requests) only when:

1. **Client-side tracking**: The JDBC driver tracks the `sessionUUID` from server responses
2. **Explicit transactions**: After `connection.setAutoCommit(false)`, subsequent operations reuse the session
3. **Result set navigation**: Fetching next rows reuses the query's session
4. **LOB operations**: Reading/writing LOB data reuses the LOB's session

**Files**:
- `ojp-jdbc-driver/src/main/java/org/openjproxy/jdbc/Connection.java`
- `ojp-jdbc-driver/src/main/java/org/openjproxy/grpc/client/SessionTracker.java`

---

## Why This Matters for Multinode

### Multinode Session Stickiness

**File**: `documents/multinode/README.md`

> **Session Stickiness**: Ensures session-bound operations stay on the same server

**Quote from line 11**:
> "Session Stickiness: Ensures session-bound operations stay on the same server"

**File**: `documents/multinode/multinode-architecture.md`

```java
// Lines 112-134
public ServerEndpoint affinityServer(String sessionKey) throws SQLException {
    if (sessionKey == null || sessionKey.isEmpty()) {
        // NO SESSION KEY: Use round-robin load balancing
        return selectHealthyServer();
    } else {
        // SESSION KEY PROVIDED: Use session stickiness
        ServerEndpoint boundServer = sessionToServerMap.get(sessionKey);
        
        if (boundServer == null) {
            // Session not bound yet - use round-robin
            return selectHealthyServer();
        }
        
        if (!boundServer.isHealthy()) {
            // Bound server is unhealthy - throw exception
            throw new SQLException("Server for session " + sessionKey + " is unavailable");
        }
        
        return boundServer;
    }
}
```

**Impact**: Without session affinity for temporary tables/session variables:
- Operations could be load-balanced to **different OJP servers**
- Each server maintains **separate connection pools**
- Session-specific SQL features **break across servers**

---

## Design Constraints and Considerations

### 1. SQL Parsing Overhead

**Concern**: Adding SQL parsing for every request could introduce:
- Performance overhead (parsing cost)
- Complexity in handling all SQL dialects
- Memory overhead for pattern matching

**Mitigation Options**:
- Lightweight pattern matching (regex on first 100 characters)
- Caching parsed results per SQL statement
- Optional feature flag to enable/disable

### 2. Database Dialect Variations

**Challenge**: Session-specific SQL varies by database:

| Database | Temporary Table Syntax | Session Variables |
|----------|----------------------|-------------------|
| PostgreSQL | `CREATE TEMP TABLE` | `SET LOCAL`, `current_setting()` |
| MySQL | `CREATE TEMPORARY TABLE` | `SET @var`, `@@session.var` |
| Oracle | `CREATE GLOBAL TEMPORARY TABLE` | `SYS_CONTEXT`, `DBMS_SESSION` |
| SQL Server | `CREATE TABLE #temp` | `SET` statements |
| H2 | `CREATE LOCAL TEMPORARY TABLE` | `SET @var` |

**Question**: Should detection be:
- **Database-agnostic** (common patterns only)?
- **Database-specific** (requires metadata.getURL() parsing)?
- **Configurable** (user provides patterns)?

### 3. Transaction Boundary Semantics

**Current Behavior**: Transactions already enforce session affinity.

**Question**: Should temporary tables created **within a transaction** automatically inherit session affinity even after `COMMIT`?

**Example**:
```sql
BEGIN TRANSACTION;
CREATE TEMP TABLE temp_data (...);
COMMIT;  -- Temp table still exists in some databases

-- Should this still use the same session?
SELECT * FROM temp_data;
```

**Database-Specific**:
- **PostgreSQL**: Temp tables persist across transactions in the same session
- **MySQL**: Temp tables persist until connection closes
- **SQL Server**: `#temp` tables persist until connection closes

### 4. Connection Pooling Implications

**Current**: OJP uses HikariCP pools where connections are returned to the pool after use.

**Problem**: If session affinity is enforced for temp tables:
- Connection must be "pinned" to the session
- Cannot be returned to the pool until session terminates
- May reduce connection pool efficiency

**Question**: Should there be:
- A timeout for session-pinned connections?
- A maximum number of pinned connections?
- Explicit API to "close session" and release connection?

### 5. Client JDBC Driver Impact

**Current**: Client driver (OJP JDBC) tracks `sessionUUID` for:
- Active transactions
- Open result sets
- LOB operations

**Question**: Should client driver:
- **Automatically** track sessions for detected SQL patterns (transparent)?
- **Explicitly** expose API for "session-bound connection" mode?
- Provide connection property like `ojp.session.detectSqlPatterns=true`?

---

## Proposed Solution Design

### Option 1: Lightweight SQL Pattern Detection (Recommended)

**Approach**: Add minimal SQL inspection on the server side before executing statements.

#### Implementation

**New Class**: `SqlSessionAffinityDetector.java`

```java
package org.openjproxy.grpc.server.sql;

public class SqlSessionAffinityDetector {
    
    private static final Pattern TEMP_TABLE_PATTERN = Pattern.compile(
        "^\\s*CREATE\\s+(GLOBAL\\s+)?TEMP(ORARY)?\\s+TABLE",
        Pattern.CASE_INSENSITIVE
    );
    
    private static final Pattern SESSION_VAR_PATTERN = Pattern.compile(
        "^\\s*SET\\s+(@|SESSION|LOCAL)",
        Pattern.CASE_INSENSITIVE
    );
    
    private static final Pattern PREPARE_PATTERN = Pattern.compile(
        "^\\s*PREPARE\\s+",
        Pattern.CASE_INSENSITIVE
    );
    
    /**
     * Determines if SQL requires session affinity.
     * 
     * @param sql The SQL statement to analyze
     * @return true if statement requires session affinity
     */
    public static boolean requiresSessionAffinity(String sql) {
        if (sql == null || sql.trim().isEmpty()) {
            return false;
        }
        
        String normalized = sql.trim();
        
        // Check for temporary tables
        if (TEMP_TABLE_PATTERN.matcher(normalized).find()) {
            return true;
        }
        
        // Check for session variables
        if (SESSION_VAR_PATTERN.matcher(normalized).find()) {
            return true;
        }
        
        // Check for prepared statements
        if (PREPARE_PATTERN.matcher(normalized).find()) {
            return true;
        }
        
        return false;
    }
}
```

#### Integration Point

**File**: `StatementServiceImpl.java`

```java
// In executeUpdate() method - BEFORE line 366
private void executeUpdateInternal(StatementRequest request, 
                                  StreamObserver<OpResult> responseObserver) {
    SessionInfo sessionInfo = request.getSession();
    String sql = request.getSql();
    
    // NEW: Check if SQL requires session affinity
    boolean requiresSession = SqlSessionAffinityDetector.requiresSessionAffinity(sql);
    
    // Create session if needed
    boolean shouldCreateSession = StatementRequestValidator.isAddBatchOperation(request) 
        || StatementRequestValidator.hasAutoGeneratedKeysFlag(request)
        || requiresSession;  // NEW CONDITION
    
    ConnectionSessionDTO dto = shouldCreateSession 
        ? this.sessionConnection(sessionInfo, true)
        : this.sessionConnection(sessionInfo, false);
    
    // ... rest of method
}
```

#### Test Cases

**New Test Class**: `SqlSessionAffinityDetectorTest.java`

```java
@Test
void testTemporaryTableDetection() {
    assertTrue(requiresSessionAffinity("CREATE TEMPORARY TABLE temp (id INT)"));
    assertTrue(requiresSessionAffinity("CREATE TEMP TABLE temp (id INT)"));
    assertTrue(requiresSessionAffinity("  CREATE TEMP TABLE temp (id INT)"));
    assertTrue(requiresSessionAffinity("create temporary table temp (id INT)"));
    assertFalse(requiresSessionAffinity("CREATE TABLE regular (id INT)"));
}

@Test
void testSessionVariableDetection() {
    assertTrue(requiresSessionAffinity("SET @user_id = 123"));
    assertTrue(requiresSessionAffinity("SET SESSION sql_mode = 'STRICT'"));
    assertTrue(requiresSessionAffinity("SET LOCAL work_mem = '4GB'"));
    assertFalse(requiresSessionAffinity("SET timezone = 'UTC'"));  // Ambiguous
}

@Test
void testPreparedStatementDetection() {
    assertTrue(requiresSessionAffinity("PREPARE stmt FROM 'SELECT ?'"));
    assertFalse(requiresSessionAffinity("EXECUTE stmt USING @var"));
}
```

**Integration Test**: `TemporaryTableSessionAffinityTest.java`

```java
@Test
void testTemporaryTableAcrossRequests() throws SQLException {
    Connection conn = DriverManager.getConnection(ojpUrl, user, password);
    
    // Create temporary table
    conn.createStatement().execute("CREATE TEMPORARY TABLE temp_data (id INT, name VARCHAR(100))");
    
    // Insert data
    conn.createStatement().executeUpdate("INSERT INTO temp_data VALUES (1, 'Alice')");
    
    // Query data - should see the row
    ResultSet rs = conn.createStatement().executeQuery("SELECT * FROM temp_data");
    assertTrue(rs.next());
    assertEquals(1, rs.getInt("id"));
    assertEquals("Alice", rs.getString("name"));
    
    conn.close();
}

@Test
void testSessionVariableAcrossRequests() throws SQLException {
    Connection conn = DriverManager.getConnection(ojpUrl, user, password);
    
    // Set session variable
    conn.createStatement().execute("SET @user_id = 12345");
    
    // Use session variable
    ResultSet rs = conn.createStatement().executeQuery("SELECT @user_id AS user_id");
    assertTrue(rs.next());
    assertEquals(12345, rs.getInt("user_id"));
    
    conn.close();
}
```

**Multinode Test**: `MultinodeTemporaryTableTest.java`

```java
@Test
void testTemporaryTableWithMultinodeStickiness() throws SQLException {
    // URL with 2 OJP servers
    String multinodeUrl = "jdbc:ojp[localhost:1059,localhost:1060]_h2:mem:testdb";
    Connection conn = DriverManager.getConnection(multinodeUrl, "sa", "");
    
    // Create temp table - should bind to specific server
    conn.createStatement().execute("CREATE TEMPORARY TABLE temp_session (data VARCHAR(100))");
    
    // Insert data - should go to same server due to session affinity
    conn.createStatement().executeUpdate("INSERT INTO temp_session VALUES ('test')");
    
    // Query data - should go to same server
    ResultSet rs = conn.createStatement().executeQuery("SELECT * FROM temp_session");
    assertTrue(rs.next());
    assertEquals("test", rs.getString("data"));
    
    conn.close();
}
```

#### Pros
- ✅ Minimal performance impact (regex on first ~50 characters)
- ✅ No client-side changes required
- ✅ Works transparently with existing code
- ✅ Database-agnostic patterns
- ✅ Easy to extend with more patterns

#### Cons
- ❌ Cannot detect all edge cases (e.g., dynamic SQL in strings)
- ❌ May miss database-specific syntax variants
- ❌ Requires maintaining pattern list

---

### Option 2: Client Hint in Protocol

**Approach**: Extend gRPC protocol to allow client to indicate session requirement.

#### Protocol Change

**File**: `StatementService.proto`

```protobuf
message StatementRequest {
    SessionInfo session = 1;
    string sql = 2;
    // ... existing fields
    
    // NEW FIELD
    bool requiresSessionAffinity = 15;  // Client hint for session-specific SQL
}
```

#### Client Implementation

**File**: `ojp-jdbc-driver/src/main/java/org/openjproxy/jdbc/Statement.java`

```java
public boolean execute(String sql) throws SQLException {
    // NEW: Check if SQL requires session
    boolean requiresAffinity = SqlPatternMatcher.requiresSessionAffinity(sql);
    
    StatementRequest request = StatementRequest.newBuilder()
        .setSql(sql)
        .setRequiresSessionAffinity(requiresAffinity)  // NEW
        .build();
    
    return statementService.execute(request);
}
```

#### Server Implementation

**File**: `StatementServiceImpl.java`

```java
private void executeUpdateInternal(StatementRequest request, ...) {
    boolean shouldCreateSession = request.getRequiresSessionAffinity()  // NEW
        || StatementRequestValidator.isAddBatchOperation(request)
        || StatementRequestValidator.hasAutoGeneratedKeysFlag(request);
    
    // ... rest of method
}
```

#### Pros
- ✅ Explicit contract between client and server
- ✅ Client can use more sophisticated SQL parsing
- ✅ Server doesn't need to parse SQL
- ✅ Backward compatible (optional field)

#### Cons
- ❌ Requires protocol version bump
- ❌ Requires client driver update
- ❌ Not transparent to existing applications
- ❌ Duplicated logic (client + server both need patterns)

---

### Option 3: Configuration-Based Session Affinity

**Approach**: Allow users to configure SQL patterns that require session affinity.

#### Configuration File

**File**: `ojp-server-config.properties`

```properties
# Session affinity SQL patterns (regex, one per line)
ojp.session.affinity.patterns=\
  ^\\s*CREATE\\s+(GLOBAL\\s+)?TEMP(ORARY)?\\s+TABLE,\
  ^\\s*SET\\s+(@|SESSION|LOCAL),\
  ^\\s*PREPARE\\s+

# Enable/disable session affinity detection
ojp.session.affinity.enabled=true
```

#### Implementation

**New Class**: `SessionAffinityConfig.java`

```java
public class SessionAffinityConfig {
    private final List<Pattern> patterns;
    private final boolean enabled;
    
    public SessionAffinityConfig(Properties props) {
        this.enabled = Boolean.parseBoolean(
            props.getProperty("ojp.session.affinity.enabled", "true")
        );
        
        String patternsStr = props.getProperty("ojp.session.affinity.patterns", "");
        this.patterns = Arrays.stream(patternsStr.split(","))
            .map(String::trim)
            .filter(s -> !s.isEmpty())
            .map(Pattern::compile)
            .collect(Collectors.toList());
    }
    
    public boolean requiresSessionAffinity(String sql) {
        if (!enabled || sql == null) {
            return false;
        }
        
        return patterns.stream()
            .anyMatch(p -> p.matcher(sql).find());
    }
}
```

#### Pros
- ✅ User can customize patterns for their database
- ✅ Can disable feature if causing issues
- ✅ No code changes needed for new patterns
- ✅ Production-tunable

#### Cons
- ❌ Requires configuration maintenance
- ❌ Users must understand regex
- ❌ Default patterns still needed for out-of-box experience

---

## Recommendations

### Short-Term (MVP)

**Implement Option 1: Lightweight SQL Pattern Detection**

**Why**:
- Minimal code changes
- No protocol changes
- Transparent to applications
- Solves 80% of common cases

**Scope**:
- Detect: `CREATE TEMPORARY TABLE`, `CREATE TEMP TABLE`, `CREATE GLOBAL TEMPORARY TABLE`
- Detect: `SET @variable`, `SET SESSION`, `SET LOCAL`
- Detect: `PREPARE` statements
- Add comprehensive tests
- Document limitation: Dynamic SQL not detected

**Files to Modify**:
1. Create `SqlSessionAffinityDetector.java`
2. Modify `StatementServiceImpl.executeUpdateInternal()` (line ~366)
3. Modify `StatementServiceImpl.executeQueryInternal()` (line ~491)
4. Add tests: `SqlSessionAffinityDetectorTest.java`
5. Add integration tests: `TemporaryTableSessionAffinityTest.java`
6. Update `documents/multinode/README.md` (add to "How It Works" section)

**Estimated Effort**: 2-3 days

---

### Medium-Term (Enhancement)

**Add Option 3: Configuration-Based Patterns**

**Why**:
- Allows users to handle database-specific cases
- Production escape hatch if detection has false positives
- Extensible without code changes

**Scope**:
- Add `SessionAffinityConfig.java`
- Add configuration properties
- Merge with Option 1 (config overrides defaults)
- Document configuration options

**Estimated Effort**: 1-2 days

---

### Long-Term (Future Consideration)

**Option 2: Protocol Extension**

**When**: If Option 1 proves insufficient (too many false negatives).

**Trigger**: User feedback indicates SQL detection misses critical cases.

**Benefit**: Client-side can use full SQL parser libraries if needed.

---

## Open Questions

### For Product Owner / Architect

1. **Performance Budget**: What is acceptable overhead for SQL pattern matching?
   - Target: < 1ms per statement?
   - Acceptable: < 5ms per statement?

2. **Feature Flag**: Should this be:
   - Always enabled by default?
   - Opt-in via connection property?
   - Controlled by server configuration?

3. **Session Lifecycle**: How should sessions be cleaned up?
   - Timeout after N seconds of inactivity?
   - Explicit close API?
   - Tied to Connection.close()?

4. **Connection Pinning**: Should pinned connections:
   - Count against pool maximum?
   - Have separate pool/quota?
   - Be logged/monitored separately?

5. **Database Support**: Should we support all databases equally or prioritize?
   - Phase 1: PostgreSQL, MySQL, H2 (most common)
   - Phase 2: Oracle, SQL Server, DB2
   - Phase 3: MariaDB, CockroachDB, others

### For Developers

1. **Test Strategy**: Should we:
   - Test against real database containers (Testcontainers)?
   - Use H2 in-memory for unit tests?
   - Both?

2. **Regex Performance**: Should patterns be:
   - Pre-compiled (current approach)?
   - Cached per SQL statement?
   - Simple string.startsWith() for common cases?

3. **Logging**: What should be logged?
   - Every session affinity detection?
   - Only when session is created due to detection?
   - Debug level only?

---

## Security Considerations

### SQL Injection Risk

**Concern**: Does SQL pattern matching introduce SQL injection vectors?

**Analysis**: **NO** - Pattern matching only influences session routing, not SQL execution.
- SQL is still executed via PreparedStatement/Statement APIs
- No string manipulation or concatenation
- Patterns only detect keywords, don't parse values

### Denial of Service

**Concern**: Could malicious patterns cause performance degradation?

**Mitigation**:
- Limit pattern matching to first 200 characters of SQL
- Use simple patterns (avoid backtracking regex)
- Cache detection results per SQL statement hash
- Add monitoring for pattern match duration

---

## Documentation Updates Needed

### 1. Multinode README

**File**: `documents/multinode/README.md`

**Section to Add** (after line 108):

```markdown
### Session Stickiness for SQL Features

The session stickiness also applies to operations like creating temporary tables 
or setting session variables. These database features are inherently session-specific, 
so they need to execute on the same server consistently.

**Supported SQL Patterns**:
- `CREATE TEMPORARY TABLE` / `CREATE TEMP TABLE`
- `SET @variable` (MySQL)
- `SET SESSION` / `SET LOCAL` (PostgreSQL)
- `PREPARE` statements

**How It Works**:
1. OJP detects session-specific SQL patterns before execution
2. Automatically creates a session if one doesn't exist
3. Routes subsequent operations to the same server via session UUID
4. Maintains connection affinity on that server

**Example**:
```sql
-- Request 1: Create temporary table - creates session, binds to server A
CREATE TEMPORARY TABLE user_session (user_id INT, token VARCHAR(100));

-- Request 2: Insert - automatically uses same session/server A
INSERT INTO user_session VALUES (123, 'abc-def-ghi');

-- Request 3: Query - automatically uses same session/server A
SELECT * FROM user_session WHERE user_id = 123;
```

**Note**: Session affinity is only required when NOT using explicit transactions. 
If you use `connection.setAutoCommit(false)`, all operations are already 
session-bound for ACID transaction guarantees.
```

### 2. Architecture Documentation

**File**: `documents/multinode/multinode-architecture.md`

**Section to Add** (after line 365):

```markdown
## SQL Pattern-Based Session Creation

In addition to JDBC-level triggers (batch, LOB, transactions), OJP also detects 
session-specific SQL patterns:

```java
// Lines added to StatementServiceImpl.executeUpdateInternal()
boolean requiresSession = SqlSessionAffinityDetector.requiresSessionAffinity(sql);

boolean shouldCreateSession = StatementRequestValidator.isAddBatchOperation(request) 
    || StatementRequestValidator.hasAutoGeneratedKeysFlag(request)
    || requiresSession;  // NEW: SQL pattern detection
```

**Detected Patterns**:
| Pattern | Example | Why Session Needed |
|---------|---------|-------------------|
| Temporary tables | `CREATE TEMP TABLE` | Table only exists in current session |
| Session variables | `SET @var = 123` | Variable scoped to current session |
| Prepared statements | `PREPARE stmt FROM` | Statement handle scoped to session |

This ensures temporary tables and session variables work correctly in both 
single-node and multinode deployments.
```

### 3. New Document: SQL Session Affinity

**File**: `documents/features/SQL_SESSION_AFFINITY.md`

Create comprehensive guide explaining:
- What SQL features require session affinity
- How detection works
- Performance implications
- Configuration options
- Troubleshooting guide
- Database-specific considerations

---

## Testing Strategy

### Unit Tests

**File**: `SqlSessionAffinityDetectorTest.java`

```java
- testTemporaryTableDetection()
- testSessionVariableDetection()
- testPreparedStatementDetection()
- testNegativeCases()
- testCaseInsensitivity()
- testWhitespaceHandling()
- testNullAndEmptyInput()
```

### Integration Tests

**File**: `TemporaryTableIntegrationTest.java`

```java
- testTemporaryTableLifecycle()
- testTemporaryTableIsolation()
- testSessionVariableLifecycle()
- testMixedSessionAndNonSessionSQL()
- testTemporaryTableWithTransaction()
```

### Multinode Tests

**File**: `MultinodeSessionAffinityTest.java`

```java
- testTemporaryTableStickiness()
- testSessionVariableStickiness()
- testServerFailureWithActiveSession()
- testLoadBalancingWithoutSession()
```

### Database-Specific Tests

**Files**:
- `PostgresTemporaryTableTest.java`
- `MySQLTemporaryTableTest.java`
- `H2TemporaryTableTest.java`

Test database-specific syntax:
- PostgreSQL: `CREATE TEMP TABLE ON COMMIT DROP`
- MySQL: `CREATE TEMPORARY TABLE ... ENGINE=MEMORY`
- H2: `CREATE LOCAL TEMPORARY TABLE`

---

## Success Criteria

Implementation is complete when:

1. ✅ Temporary tables work across multiple requests without explicit transactions
2. ✅ Session variables persist across multiple requests without explicit transactions
3. ✅ Multinode session stickiness applies to temporary tables and session variables
4. ✅ Integration tests pass for PostgreSQL, MySQL, H2
5. ✅ Performance overhead < 2ms per statement (99th percentile)
6. ✅ Documentation updated with examples and limitations
7. ✅ No breaking changes to existing functionality
8. ✅ Code review approved

---

## Conclusion

**Current Status**: Session affinity for temporary tables and session variables is **NOT supported**.

**Impact**: Medium - Affects applications using these SQL features without explicit transactions.

**Solution**: Lightweight SQL pattern detection (Option 1) is recommended for MVP.

**Effort**: 2-3 days for basic implementation + tests + documentation.

**Risk**: Low - Non-invasive change, backward compatible, easy to disable if issues arise.

**Next Steps**:
1. Review and approve this analysis
2. Prioritize implementation in roadmap
3. Assign developer to implement Option 1
4. Schedule testing with real-world applications

---

## Appendix A: Related Files

### Server-Side
- `ojp-server/src/main/java/org/openjproxy/grpc/server/StatementServiceImpl.java`
- `ojp-server/src/main/java/org/openjproxy/grpc/server/SessionManager.java`
- `ojp-server/src/main/java/org/openjproxy/grpc/server/Session.java`
- `ojp-server/src/main/java/org/openjproxy/grpc/server/StatementRequestValidator.java`

### Client-Side
- `ojp-jdbc-driver/src/main/java/org/openjproxy/grpc/client/MultinodeConnectionManager.java`
- `ojp-jdbc-driver/src/main/java/org/openjproxy/grpc/client/MultinodeStatementService.java`
- `ojp-jdbc-driver/src/main/java/org/openjproxy/jdbc/Connection.java`

### Protocol
- `ojp-grpc-commons/src/main/proto/StatementService.proto`

### Documentation
- `documents/multinode/README.md`
- `documents/multinode/multinode-architecture.md`

---

## Appendix B: Database-Specific Temporary Table Syntax

### PostgreSQL
```sql
CREATE TEMP TABLE name (...);
CREATE TEMPORARY TABLE name (...);
CREATE LOCAL TEMP TABLE name (...);
CREATE TEMP TABLE name (...) ON COMMIT DROP;
CREATE TEMP TABLE name (...) ON COMMIT PRESERVE ROWS;
```

### MySQL
```sql
CREATE TEMPORARY TABLE name (...);
CREATE TEMPORARY TABLE name (...) ENGINE=MEMORY;
```

### Oracle
```sql
CREATE GLOBAL TEMPORARY TABLE name (...)
  ON COMMIT DELETE ROWS;  -- Default
  
CREATE GLOBAL TEMPORARY TABLE name (...)
  ON COMMIT PRESERVE ROWS;
```

### SQL Server
```sql
CREATE TABLE #temp_table (...);  -- Local temp (session scope)
CREATE TABLE ##global_temp (...);  -- Global temp
```

### H2
```sql
CREATE LOCAL TEMPORARY TABLE name (...);
CREATE TEMPORARY TABLE name (...);
```

### DB2
```sql
DECLARE GLOBAL TEMPORARY TABLE name (...)
  ON COMMIT PRESERVE ROWS;
```

---

**Document Version**: 1.0  
**Date**: 2026-01-19  
**Author**: GitHub Copilot Analysis  
**Status**: Draft for Review
